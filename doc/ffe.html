<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- This file documents version 0.3.7-1 of ffe, a flat file extractor. 

Copyright (C) 2014 Timo Savinen

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions. -->
<!-- Created by GNU Texinfo 5.2, http://www.gnu.org/software/texinfo/ -->
<head>
<title>ffe - flat file extractor</title>

<meta name="description" content="ffe - flat file extractor">
<meta name="keywords" content="ffe - flat file extractor">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="#Top" rel="start" title="Top">
<link href="#SEC_Contents" rel="contents" title="Table of Contents">
<link href="dir.html#Top" rel="up" title="(dir)">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.indentedblock {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smallindentedblock {margin-left: 3.2em; font-size: smaller}
div.smalllisp {margin-left: 3.2em}
kbd {font-style:oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nocodebreak {white-space:nowrap}
span.nolinebreak {white-space:nowrap}
span.roman {font-family:serif; font-weight:normal}
span.sansserif {font-family:sans-serif; font-weight:normal}
ul.no-bullet {list-style: none}
body {
	margin: 1%;
	padding: 0 5%;
	background: white;
	font-family: serif;
	text-align: justify;
}

h1,h2,h3,h4,h5 {
    padding: 0.5em 0 0 0;
    font-weight: bold;
    font-family: sans-serif;
}

h1 {
    padding: 0.5em 0 0.5em 1em;
    color: white;
    background: #575;
}

pre {
  margin: 0;
  padding: 0.5em 0.5em 0.5em 0;
}

pre.example {
  padding: 0;
  margin: 0;
  background: #eee;
}

pre.verbatim, .menu {
  border: solid 1px gray;
  background: white;
  padding-bottom: 1em;
}

div.node {
  background: #ccc;
  margin: 0;
  padding: 0 1.5em;
  font-weight: lighter;
  color: #000;
  text-align: right;
}

.node a {
  color: #770000;
}

.node a:visited {
  color: #550000;
}

dd, li {
  padding-top: 0.1em;
  padding-bottom: 0.1em;
}

samp {
	font: inherit;
}

code {
	font-size: inherit;
    font-weight: bold;
}

pre, code { 
	font-family: monospace;
}

.command, .file {
   font-family: monospace;
} 

div.node hr {
    display:none;
}

-->
</style>


</head>

<body lang="en" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">
<h1 class="settitle" align="center">ffe - flat file extractor</h1>





<a name="Top"></a>
<a name="ffe"></a>
<h1 class="top">ffe</h1>

<p>This file documents version 0.3.7-1 of <code>ffe</code>, a flat file extractor. 
</p>
<p>Copyright &copy; 2014 Timo Savinen
</p>
<blockquote>
<p>Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.
</p>
<p>Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.
</p>
<p>Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions.
</p></blockquote>




<hr>
<a name="Overview"></a>
<a name="Preliminary-information"></a>
<h2 class="chapter">1 Preliminary information</h2>
<a name="index-greetings"></a>
<a name="index-overview"></a>

<p>The <code>ffe</code> is a program to extract fields from text and binary flat files and to print them in different
formats. The input file structure and printing definitions are specified in a configuration file, which
is always required. Default configuration file is <samp>~/.fferc</samp> (<samp>ffe.rc</samp> in windows).
</p>
<p><code>ffe</code> is a command line tool developed for GNU/Linux and UNIX systems. <code>ffe</code> can read from
standard input and write to standard output, so it can be used as a part of a pipeline.
</p>
<p>There is also binary distribution for windows.
</p>
<hr>
<a name="Samples"></a>
<a name="Samples-using-ffe"></a>
<h2 class="chapter">2 Samples using <code>ffe</code></h2>
<a name="index-sample"></a>

<p>One example of using <code>ffe</code> for printing personnel information in XML format from fixed length flat file:
</p>
<div class="example">
<pre class="example">$ cat personnel
john     Ripper       23
Scott    Tiger        45
Mary     Moore        41
$
</pre></div>

<p>A file <samp>personnel</samp> contains three fixed length fields: &lsquo;<samp>FirstName</samp>&rsquo;, &lsquo;<samp>LastName</samp>&rsquo; and &lsquo;<samp>Age</samp>&rsquo;,
their respective lengths are 9,13 and 2.
</p>
<p>In order to print data above in XML, following configuration file must be available:
</p>
<div class="example">
<pre class="example">$cat personnel.fferc
structure personel {
    type fixed
    output xml
    record person {
        field FirstName 9
        field LastName  13
        field Age 2
    }
}

output xml {
    file_header &quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;ISO-8859-1\&quot;?&gt;\n&quot;
    data &quot;&lt;%n&gt;%t&lt;/%n&gt;\n&quot;
    record_header &quot;&lt;%r&gt;\n&quot;
    record_trailer &quot;&lt;/%r&gt;\n&quot;
    indent &quot; &quot;
}
$
</pre></div>

<p>Using ffe:
</p>
<div class="example">
<pre class="example">$ffe -c personnel.fferc personnel
&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;
 &lt;person&gt;
  &lt;FirstName&gt;john&lt;/FirstName&gt;
  &lt;LastName&gt;Ripper&lt;/LastName&gt;
  &lt;Age&gt;23&lt;/Age&gt;
 &lt;/person&gt;
 &lt;person&gt;
  &lt;FirstName&gt;Scott&lt;/FirstName&gt;
  &lt;LastName&gt;Tiger&lt;/LastName&gt;
  &lt;Age&gt;45&lt;/Age&gt;
 &lt;/person&gt;
 &lt;person&gt;
  &lt;FirstName&gt;Mary&lt;/FirstName&gt;
  &lt;LastName&gt;Moore&lt;/LastName&gt;
  &lt;Age&gt;41&lt;/Age&gt;
 &lt;/person&gt;
$
</pre></div>

<hr>
<a name="Invoking-ffe"></a>
<a name="How-to-run-ffe"></a>
<h2 class="chapter">3 How to run <code>ffe</code></h2>
<a name="index-running-ffe"></a>
<a name="index-using"></a>

<p><code>ffe</code> is a command line tool. Normally <code>ffe</code> can be invoked as:
</p>
<p><code>ffe -o OUTPUTFILE INPUTFILE&hellip;</code>
</p>
<p><code>ffe</code> uses the definitions from the configuration file and tries to guess the input file
structure.
</p>
<p>If the structure cannot be guessed the option <samp>-s</samp> must be used.
</p>

<hr>
<a name="Invocation"></a>
<a name="Program-invocation"></a>
<h3 class="section">3.1 Program invocation</h3>
<a name="index-options"></a>

<p>The format for running the <code>ffe</code> program is:
</p>
<div class="example">
<pre class="example">ffe <var>option</var> &hellip;
</pre></div>

<p><code>ffe</code> supports the following options:
</p>
<dl compact="compact">
<dt><code>-c <var>file</var></code></dt>
<dt><code>--configuration=<var>file</var></code></dt>
<dd><p>Configuration is read from <var>file</var>, instead of <samp>~/.fferc</samp> (<samp>ffe.rc</samp> in windows).
</p>
</dd>
<dt><code>-s <var>structure</var></code></dt>
<dt><code>--structure=<var>structure</var></code></dt>
<dd><p>Use structure <var>structure</var> for input file, suppresses guessing.
</p>
</dd>
<dt><code>-p <var>output</var></code></dt>
<dt><code>--print=<var>output</var></code></dt>
<dd><p>Use output format <var>output</var> for printing. If not given, then the record or structure related
output format is used. Printing can be suppressed using format <var>no</var>. Original data is printed using format <var>raw</var>.
</p>
</dd>
<dt><code>-o <var>file</var></code></dt>
<dt><code>--output=<var>file</var></code></dt>
<dd><p>Write output to <var>file</var> instead of standard output.
</p>
</dd>
<dt><code>-f <var>list</var></code></dt>
<dt><code>--field-list=<var>list</var></code></dt>
<dd><p>Print only fields and constants listed in the comma separated list <var>list</var>. Order of names in 
<var>list</var> specifies also the printing order.
</p>
</dd>
<dt><code>-e <var>expression</var></code></dt>
<dt><code>--expression=<var>expression</var></code></dt>
<dd><p>Print only those records for which the <var>expression</var> evaluates to true.
</p>
</dd>
<dt><code>-a</code></dt>
<dt><code>--and</code></dt>
<dd><p>Expressions are combined with logical and, default is logical or.
Note that if the same field and operator appear several time in expressions they are always compared with logical or.
</p>
</dd>
<dt><code>-X</code></dt>
<dt><code>--casecmp</code></dt>
<dd><p>Expressions are evaluated using case insensitive comparison
</p>
</dd>
<dt><code>-v</code></dt>
<dt><code>--invert-match</code></dt>
<dd><p>Print only those records which don&rsquo;t match the expression.
</p>
</dd>
<dt><code>-l</code></dt>
<dt><code>--loose</code></dt>
<dd><p>Normally <code>ffe</code> stops when it encounters an input line or binary block which doesn&rsquo;t match any of
the records in selected structure. Defining this option causes <code>ffe</code> continue despite the error.
Note that invalid lines are reported only for text input. In case of binary input next valid block is silently searched.
</p>
</dd>
<dt><code>-r</code></dt>
<dt><code>--replace=<var>field</var>=<var>value</var></code></dt>
<dd><p>Replace <var>field</var>s contents with <var>value</var> in output. <var>value</var> can contain same directives as output option <code>data</code>.
</p>
</dd>
<dt><code>-d</code></dt>
<dt><code>--debug</code></dt>
<dd><p>All invalid input lines are written to <samp>ffe_error_&lt;pid&gt;.log</samp>, where <samp>&lt;pid&gt;</samp> is the process ID.
</p>
</dd>
<dt><code>-I</code></dt>
<dt><code>--info</code></dt>
<dd><p>Show structure information in the configuration file and exit successfully. For every structure following information in shown:
<br>
Structures: Name, type and maximum record length. 
<br>
Records: Name and length
<br>
Fields: Name, position and length. First position is number one.
</p>
</dd>
<dt><code>-?</code></dt>
<dt><code>--help</code></dt>
<dd><p>Print an informative help message describing the options and then exit
successfully.
</p>
</dd>
<dt><code>-V</code></dt>
<dt><code>--version</code></dt>
<dd><p>Print the version number of <code>ffe</code> and then exit successfully.
</p></dd>
</dl>

<p>All remaining options are names of input files, if no input files are specified or <code>-</code> is given, then the standard input is read.
</p>
<a name="Expressions-_0028option-_002de_002c-_002d_002dexpression_0029"></a>
<h4 class="subheading">Expressions (option <samp>-e</samp>, <samp>--expression</samp>)</h4>
<p>Expression can be used to select specific records comparing field values. 
Expression has syntax <var>field</var><strong>x</strong><var>value</var>, where <strong>x</strong> is the comparison operator.
Expression is used to compare field&rsquo;s contents to <var>value</var> and if comparison is successful
the record is printed. Several expressions can be given and at least one must evaluate to true in
order to print a record. If option <samp>-a</samp> is given all expressions must evaluate to true.
</p>
<p>If <var>value</var> starts with string <code>file:</code> then the rest of <var>value</var> is considered as a file name.
Every line in file is used as <var>value</var> in comparison. Comparison evaluates true if one or more values matches, so this makes possible use several different values in comparison. <strong>Note</strong>: The file size is limited by available memory because the file contents is loaded to memory. 
</p>
<p>When comparing binary fields the <var>value</var> must have the representation which can be shown using the <code>%d</code> output directive. Note that the printing option <var>hex-caps</var> takes effect in comparison.
</p>
<p>Expression notation:
</p>
<dl compact="compact">
<dt><var>field<strong>=</strong>value</var></dt>
<dd><p>Field <var>field</var> is equal to <var>value</var>.
</p>
</dd>
<dt><var>field<strong>^</strong>value</var></dt>
<dd><p>Field <var>field</var> starts with <var>value</var>.
</p>
</dd>
<dt><var>field<strong>~</strong>value</var></dt>
<dd><p>Field <var>field</var> contains <var>value</var>.
</p>
</dd>
<dt><var>field<strong>!</strong>value</var></dt>
<dd><p>Field <var>field</var> is not equal to <var>value</var>.
</p>
</dd>
<dt><var>field<strong>?</strong>value</var></dt>
<dd><p>Field <var>field</var> matches the regular expression <var>value</var>. 
<code>ffe</code> supports POSIX extended regular expressions. 
</p></dd>
</dl>

<hr>
<a name="Configuration"></a>
<a name="Configuration-1"></a>
<h3 class="section">3.2 Configuration</h3>
<a name="index-configuration"></a>

<p><code>ffe</code> uses configuration file in order to read the input file and print the output.
</p>
<p>Configuration file for <code>ffe</code> is a text file. The file may contain empty lines. 
Commands are case sensitive. Comments  begin with the <code>#</code>-character and end at the end of the line. 
The <code>string</code> definitions can be enclosed in double quotation <code>&quot;</code> characters. 
<code>char</code> is a single character. <code>string</code> and <code>char</code> can contain following escape codes: 
<code>\a</code>, <code>\b</code>, <code>\t</code>, <code>\n</code>, <code>\v</code>, <code>\f</code>, <code>\r</code>, <code>\&quot;</code> and <code>\#</code>. 
A backslash can be escaped as <code>\\</code>.
</p>
<p>Configuration has two main parts: the structure, which specifies the input file structure and 
the output, which specifies how the input data is formatted for output.
</p>
<a name="Common-syntax"></a>
<h4 class="subheading">Common syntax</h4>
<p>Common syntax for configuration file is:
</p>
<div class="example">
<pre class="example">#comment
`command`
const <var>name</var> <var>value</var>
filter <var>name</var> <var>value</var>
&hellip;
structure <var>name</var> {
    <i>option value</i> &hellip;
    &hellip;
    record <var>name</var> {
        <i>option value</i> &hellip;
        &hellip;
    }
    record <var>name</var> {
        <i>option value</i> &hellip;
        &hellip;
    }
    &hellip;
}
structure <var>name</var> {
    &hellip;
}
&hellip;
output <var>name</var> {
    <i>option value</i> &hellip;
    &hellip;
}
output <var>name</var> {
    &hellip;
}
&hellip;
lookup <var>name</var> {
    <i>option value</i> &hellip;
    &hellip;
}
lookup <var>name</var> {
    &hellip;
}

&hellip;
</pre></div>

<a name="Structure"></a>
<h4 class="subheading">Structure</h4>
<p>Keyword <code>structure</code> is used to specify the input file content. An input file can contain several
types of records (lines or binary blocks). E.g. file can have a header, data and trailer record types. Records
must be distinguishable from each other, this can be achieved defining different &rsquo;keys&rsquo; 
(<code>id</code> in record definition) or having different line lengths (for fixed length) or different count
of fields (for separated structure) for different records.
</p>
<p>If binary structure has several records, then all records must have at least one key (<code>id</code>), because binary blocks can
be distinguished only by using keys.
</p>
<p>The structure notation:
<br>
</p>
<div class="example">
<pre class="example">structure <var>name</var> {
    <i>option value</i> &hellip;
    &hellip;
}
</pre></div>

<p>A structure can contain following options:
</p>
<dl compact="compact">
<dt><code>type fixed|binary|separated [<var>char</var>] [*]</code></dt>
<dd><p>The fields in the input are fixed length fields (text or binary) or text fields separated by <var>char</var>. If * is given,
multiple sequential separators are considered as one. Default separator is comma.
</p>
</dd>
<dt><code>quoted [<var>char</var>]</code></dt>
<dd><p>Fields may be quoted with char, default quotation mark is the double quotation mark &rsquo;&quot;&rsquo;.
A quotation mark is assumed to be escaped as \<var>char</var> or doubling the mark as <var>charchar</var> in input.
Non escaped quotation marks are not preserved in output.
</p>
</dd>
<dt><code>header first|all|no</code></dt>
<dd><p>Controls the occurrence of the header line. Default is no. If set as <em>first</em> or <em>all</em>, the first line
of the first input file is considered as header line containing the names of  the  fields. <em>first</em>
means  that  only  the  first  file  has  a header, <em>all</em> means means that all files have a header,
although the names are still taken from the header of the first file. Header line is handled
according the record definition, meaning that the name positions, separators etc. are the same as
for the fields. Binary files cannot have a header.
</p>
</dd>
<dt><code>output <var>name</var>|no|raw</code></dt>
<dd><p>All records belonging to this structure are printed according output format name.
Default is to use output named as &lsquo;<samp>default</samp>&rsquo;. &lsquo;<samp>no</samp>&rsquo; prints nothing and &lsquo;<samp>raw</samp>&rsquo; prints only the original data.
</p>
</dd>
<dt><code>record <var>name</var> {<i>options</i> &hellip;}</code></dt>
<dd><p>Specifies one record for a structure. A structure can contain several record types.
</p></dd>
</dl>

<a name="Record"></a>
<h4 class="subheading">Record</h4>
<p>A record specifies one type of input line or binary block in a file. Different records can be distinguished using 
the <code>id</code> option or different line lengths or field counts. In multi-record binary structure every record must have at least one <code>id</code> because binary records do not have a special end of record marker as text lines have.
</p>
<p>The record notation:
<br>
</p>
<div class="example">
<pre class="example">record <var>name</var> {
    <i>option value</i> &hellip;
    &hellip;
}
</pre></div>
<p>A record can contain following options:
</p>
<dl compact="compact">
<dt><code>id <var>position</var> <var>string</var></code></dt>
<dt><code>rid <var>position</var> <var>regexp</var></code></dt>
<dd><p>Identifies a record in the input file. Records are identified by the <var>string</var> or by the regular expression <var>regexp</var> in input record position
<var>position</var>. For fixed length and binary input the position is the byte position of input record and for
separated input the <var>position</var> is the <var>position</var>&rsquo;th field of the input record. Positions starts always from one.
</p>
<p>A record definition can contain several id&rsquo;s, then all id&rsquo;s must match the input line 
(<code>id</code>&rsquo;s are <em>and-ed</em>).
</p>
<p>Non printable characters can be escaped as &lsquo;<samp>\xnn</samp>&rsquo;, where &lsquo;<samp>nn</samp>&rsquo; is characters hexadecimal value.
</p>
</dd>
<dt><code>field <var>name</var>|FILLER|* [<var>length</var>]|* [<var>lookup</var>]|* [<var>output</var>]|* [<var>filter</var>]</code></dt>
<dd><p>Defines a field in a text input structure.  <var>length</var> is mandatory for fixed length input structure.
</p>
<p>The last field of a fixed length input structure can have a <em>*</em> in place of <var>length</var>. That means that the last field
has no exact length specified and it gets the remainder of the input line after all other fields. This allows a
fixed record to have arbitrary long last field.
</p>
<p>Length is also used for printing the fields in fixed length format (directive <code>%D</code> in output definitions).
</p>
<p>If <em>*</em> is given instead of the name, then the <var>name</var> will be the ordinal number of the field,
or if the <code>header</code> option has value <em>first</em> or <em>all</em>, then the name of the field will be taken from
the header line (first line of the input).
</p>
<p>If <var>lookup</var> is given then the fields contents is used to make a lookup in lookup table <var>lookup</var>. 
If <var>length</var> is not needed (separated format) but lookup is needed, use asterisk (*) in place of length definition.
</p>
<p>If <var>output</var> is given the field will be printed using output definition <var>output</var>. If <var>length</var> and/or <var>lookup</var> are not needed use asterisk in place of them. Use asterisk (*) if not needed.
</p>
<p>If <var>filter</var> is given the raw contents of the field is filtered through a program defined by <var>filter</var> and the output of the program is printed as field contents.
</p>
<p>If field is named as <code>FILLER</code>, the field will not appear in output.
</p>
<p>The order of fields in configuration file is essential, it specifies the field order in a record.
</p></dd>
<dt><code>field <var>name</var>|FILLER|* <var>length</var>|<var>type</var> [<var>lookup</var>]|* [<var>output</var>]|* [<var>filter</var>]</code></dt>
<dd><p>Defines a field in a binary structure. All other features are same as for text structure fields except the <var>type</var> parameter.
</p>
<p><var>type</var> specifies the field length and type and can have the following values:
</p>
<dl compact="compact">
<dt><code>char</code></dt>
<dd><p>Printable character.
</p></dd>
<dt><code>short</code></dt>
<dd><p>Short integer having current system length and byte order.
</p></dd>
<dt><code>int</code></dt>
<dd><p>Integer having current system length and byte order.
</p></dd>
<dt><code>long</code></dt>
<dd><p>Long integer having current system length and byte order.
</p></dd>
<dt><code>llong</code></dt>
<dd><p>Long long integer having current system length and byte order.
</p></dd>
<dt><code>ushort</code></dt>
<dd><p>Unsigned short integer having current system length and byte order.
</p></dd>
<dt><code>uint</code></dt>
<dd><p>Unsigned integer having current system length and byte order.
</p></dd>
<dt><code>ulong</code></dt>
<dd><p>Unsigned long integer having current system length and byte order.
</p></dd>
<dt><code>ullong</code></dt>
<dd><p>Unsigned long long integer having current system length and byte order.
</p></dd>
<dt><code>int8</code></dt>
<dd><p>8 bit integer.
</p></dd>
<dt><code>int16_be</code></dt>
<dd><p>Big endian 16 bit integer.
</p></dd>
<dt><code>int32_be</code></dt>
<dd><p>Big endian 32 bit integer.
</p></dd>
<dt><code>int64_be</code></dt>
<dd><p>Big endian 64 bit integer.
</p></dd>
<dt><code>int16_le</code></dt>
<dd><p>Little endian 16 bit integer.
</p></dd>
<dt><code>int32_le</code></dt>
<dd><p>Little endian 32 bit integer.
</p></dd>
<dt><code>int64_le</code></dt>
<dd><p>Little endian 64 bit integer.
</p></dd>
<dt><code>uint8</code></dt>
<dd><p>Unsigned 8 bit integer.
</p></dd>
<dt><code>uint16_be</code></dt>
<dd><p>Unsigned big endian 16 bit integer.
</p></dd>
<dt><code>uint32_be</code></dt>
<dd><p>Unsigned big endian 32 bit integer.
</p></dd>
<dt><code>uint64_be</code></dt>
<dd><p>Unsigned big endian 64 bit integer.
</p></dd>
<dt><code>uint16_le</code></dt>
<dd><p>Unsigned little endian 16 bit integer.
</p></dd>
<dt><code>uint32_le</code></dt>
<dd><p>Unsigned little endian 32 bit integer.
</p></dd>
<dt><code>uint64_le</code></dt>
<dd><p>Unsigned little endian 64 bit integer.
</p></dd>
<dt><code>float</code></dt>
<dd><p>Float having current system length and byte order.
</p></dd>
<dt><code>float_be</code></dt>
<dd><p>Float having current system length and big endian byte order.
</p></dd>
<dt><code>float_le</code></dt>
<dd><p>Float having current system length and little endian byte order.
</p></dd>
<dt><code>double</code></dt>
<dd><p>Double having current system length and byte order.
</p></dd>
<dt><code>double_be</code></dt>
<dd><p>Double having current system length and big endian byte order.
</p></dd>
<dt><code>double_le</code></dt>
<dd><p>Double having current system length and little endian byte order.
</p></dd>
<dt><code>bcd_be_<var>len</var></code></dt>
<dd><p>Bcd number having length <var>len</var> and nybbles in big endian order.
</p></dd>
<dt><code>bcd_le_<var>len</var></code></dt>
<dd><p>Bcd number having length <var>len</var> and nybbles in little endian order.
</p></dd>
<dt><code>hex_be_<var>len</var></code></dt>
<dd><p>Hexadecimal data in big endian order having length <var>len</var>.
</p></dd>
<dt><code>hex_le_<var>len</var></code></dt>
<dd><p>Hexadecimal data in little endian order having length <var>len</var>.
</p></dd>
</dl>

<p>If <var>length</var> is given instead of the <var>type</var>, then the field is assumed to be a printable string having length <var>length</var>. String is printed until <var>length</var> characters are printed or NULL character is found.
</p>
<p>Bcd number (<code>bcd_be_<var>len</var></code> and <code>bcd_le_<var>len</var></code>) is printed until <var>len</var> bytes are read or a nybble having hexadecimal value <code>f</code> is found.
Bcd number having big endian order is printed in order: most significant nybble first and least significant nybble second and bcd number having little endian order is printed in order: least significant nybble first and most significant nybble second. Bytes are always read in big endian order.
</p>
<p>Hexadecimal data (<code>hex_be_<var>len</var></code> and <code>hex_le_<var>len</var></code>) is printed as hexadecimal values. Big endian data is printed starting from lower address and little endian data starting from upper address.
</p>
</dd>
<dt><code>field-count <var>number</var></code></dt>
<dd><p>Same effect as having &quot;<code>field *</code>&quot; <var>number</var> times. This can be used in separated structure instead of
writing sequential &quot;<code>field *</code>&quot; definitions. Several <code>field-count</code>s can be used in the same record and
they can be mixed with <code>field</code>.
</p></dd>
<dt><code>fields-from <var>record</var></code></dt>
<dd><p>Fields in this record are the same as in record <var>record</var>. <code>field</code> and <code>fields-from</code> are mutually
exclusive.
</p></dd>
<dt><code>output <var>name</var>|no|raw</code></dt>
<dd><p>This record is printed according to output format <var>name</var>. Default is to use output format specified in structure.
</p></dd>
<dt><code>level <var>number</var> [<var>element_name</var>|*] [<var>group_name</var>]</code></dt>
<dd><p>Levels can be used to print the file in hierarchical multi-level nested form document.
<var>number</var> is the level of the record, starting from number one (highest level), 
<var>element_name</var> is the name for the record, <var>group_name</var> 
is used to group records in the same and lower levels. Only <var>number</var> is mandatory.
Use * instead of the element name if group name is needed.
</p></dd>
<dt><code>record-length strict|minimum</code></dt>
<dd><dl compact="compact">
<dt><code>strict</code></dt>
<dd><p>Input record length (fixed format) or field count (separated format)  must match the record definition in order to get it processed. This is the default value.
</p></dd>
<dt><code>minimum</code></dt>
<dd><p>Input record length or field count can be the same or longer as defined for the record. The rest of the input line is ignored.
</p></dd>
</dl>
</dd>
<dt><code>variable-length <var>record_length</var> <var>variable_length_field</var> <var>adjust</var></code></dt>
<dd><p><var>record_length</var> and <var>variable_length_field</var> are the names of two fields in the record and <var>adjust</var> is a signed integer.
Record length is read from field <var>record_length</var>. <var>record_length</var> is assumed to be an integer type for binary structures or contain only decimal numbers in fixed length structure. 
<var>record_length</var> is assumed to contain the total length of the record. 
<var>variable_length_field</var> is the field having variable length. The length of <var>variable_length_field</var> is calculated by subtracting the total length of the all other fields from the length read from <var>record_length</var>.
<br>
The length given by keyword <var>field</var> for <var>variable_length_field</var> is ignored. After calculating the length it is adjusted by <var>adjust</var>. <var>adjust</var> can be used in cases where the length read from <var>variable_length_field</var> does not contain the total length of the record.  variable-length can be used with binary or fixed lengths structures only.
</p></dd>
</dl>

<a name="Output"></a>
<h4 class="subheading">Output</h4>
<p>Keyword <code>output</code> specifies a output format for formatting the input data for output. Formatting
is controlled using options and printf style directives. An output definition is independent
from structure, so one output format can be used with different input file formats.
</p>
<p>The output notation:
<br>
</p>
<div class="example">
<pre class="example">output <var>name</var> {
    <i>option value</i> &hellip;
    &hellip;
}
</pre></div>

<p>Actual formatting and printing is controlled using <em>pictures</em> in output options. Pictures can contain
following printf style directives:
</p>
<dl compact="compact">
<dt><code>%f</code></dt>
<dd><p>Name of the input file.
</p></dd>
<dt><code>%s</code></dt>
<dd><p>Name of the current structure.
</p></dd>
<dt><code>%r</code></dt>
<dd><p>Name of the current record.
</p></dd>
<dt><code>%o</code></dt>
<dd><p>Input record number in current file.
</p></dd>
<dt><code>%O</code></dt>
<dd><p>Input record number starting from the first file.
</p></dd>
<dt><code>%i</code></dt>
<dd><p>Byte offset of the current record in the current file. Starts from zero.
</p></dd>
<dt><code>%I</code></dt>
<dd><p>Byte offset of the current record starting from the first file. Starts from zero.
</p></dd>
<dt><code>%n</code></dt>
<dd><p>Field name.
</p></dd>
<dt><code>%t</code></dt>
<dd><p>Field contents, without leading and trailing white-spaces. 
</p></dd>
<dt><code>%d</code></dt>
<dd><p>Field contents. Binary integer is printed as a decimal value. Floating point number is printed in the style <code>[-]ddd.ddd</code>, where the number of digits after the decimal-point character is 6. Bcd number is printed as a decimal number and hexadecimal data as consecutive hexadecimal values.
</p></dd>
<dt><code>%D</code></dt>
<dd><p>Field contents, right padded to the field length (requires length definition for the field).
</p></dd>
<dt><code>%C</code></dt>
<dd><p>Field contents, right padded to the field length (requires length definition for the field). Contents is cut if the input field
is longer than output length.
</p></dd>
<dt><code>%x</code></dt>
<dd><p>Unsigned hexadecimal value of a binary integer. Other fields are printed as directive <code>%d</code> would be used.
</p></dd>
<dt><code>%l</code></dt>
<dd><p>Lookup value which has been found using current field as a search key.
</p></dd>
<dt><code>%L</code></dt>
<dd><p>Lookup value, right padded to the field length.
</p></dd>
<dt><code>%p</code></dt>
<dd><p>Fields start position in a record. For fixed and binary structure this is field&rsquo;s byte position in the input line
and for separated structure this is the ordinal number of the field. Starts from one.
</p></dd>
<dt><code>%h</code></dt>
<dd><p>Hexadecimal dump of a field. Byte values are printed as consecutive <code>xnn</code> values, where the <code>nn</code> is the hexadecimal value of a byte. Data is printed before any endian conversion.
</p></dd>
<dt><code>%e</code></dt>
<dd><p>Does not print anything, causes still the &quot;field empty&quot; check to be performed.
Can be  used  when only the names of non-empty fields should be printed.
</p></dd>
<dt><code>%g</code></dt>
<dd><p>Group name given by the keyword <code>group_name</code> in record definition.
</p></dd>
<dt><code>%m</code></dt>
<dd><p>Element name given by the keyword <code>element_name</code> in record definition.
</p></dd>
<dt><code>%%</code></dt>
<dd><p>Percent sign.
</p></dd>
</dl>

<p>Output options:
</p><dl compact="compact">
<dt><code>file_header <var>picture</var></code></dt>
<dd><p><var>picture</var> is printed once before file contents.
</p></dd>
<dt><code>file_trailer <var>picture</var></code></dt>
<dd><p><var>picture</var> is printed once after file contents.
</p></dd>
<dt><code>header <var>picture</var></code></dt>
<dd><p>If given, then the header line describing the field names is printed before records.
Every field name is printed according the <var>picture</var> using the same separator and field length as
given for the fields. Picture can contain only <code>%n</code> directive.
</p></dd>
<dt><code>data <var>picture</var></code></dt>
<dd><p>Field contents is printed according <var>picture</var>.
</p></dd>
<dt><code>lookup <var>picture</var></code></dt>
<dd><p>If current field is related to lookup table, then this <var>picture</var> is used instead of picture from <code>data</code>.
This makes possible to use different picture when the field is related to a lookup table. Default is to use the picture from <code>data</code>.
</p></dd>
<dt><code>separator <var>string</var></code></dt>
<dd><p>All fields are terminated by <var>string</var>, except the last field of the record.
Default is not to print separator.
</p></dd>
<dt><code>record_header <var>picture</var></code></dt>
<dd><p><var>picture</var> is printed before the record content. Default is not to print the record header.
</p></dd>
<dt><code>record_trailer <var>picture</var></code></dt>
<dd><p><var>picture</var> is printed after the record content. Default is newline.
</p></dd>
<dt><code>justify left|right|<var>char</var></code></dt>
<dd><p>The output from the <code>data</code> option is left or right justified. 
<var>char</var> justifies output according the first occurrence of <var>char</var>
in the data picture. Default is left.
</p></dd>
<dt><code>indent <var>string</var></code></dt>
<dd><p>Record contents is intended by <var>string</var>. 
Field contents is intended by two times the string. Default is not to indent.
If file contents is printed in hierarchical form (keyword <code>level</code> in record definition) then
contents is indented according the level of a record.
</p></dd>
<dt><code>field-list <var>name1</var>,<var>name2</var>,&hellip;</code></dt>
<dd><p>Only fields and constants named as <var>name1</var>,<var>name2</var>,&hellip; are printed, same effect as has option <samp>-f</samp>. 
Default is print all fields and no constants. Fields and constants are also printed in the same order as they are listed.
</p></dd>
<dt><code>no-data-print yes|no</code></dt>
<dd><p>If <code>field-list</code> is given and and this is set as no and none of the fields in <code>field-list</code>
does not belong to the current record, then the <code>record_header</code> and <code>record_trailer</code> are not printed.
Default is yes.
</p></dd>
<dt><code>field-empty-print yes|no</code></dt>
<dd><p>When set as no, nothing is printed for the fields which consist entirely of characters from <code>empty-chars</code>. 
If none of the fields of a record are printed, then the printing of <code>record_trailer</code> is also suppressed. 
Default is yes.
</p></dd>
<dt><code>empty-chars <var>string</var></code></dt>
<dd><p><var>string</var> specifies a set of characters which consist an &quot;empty&quot; field. Default is
&quot;&nbsp;\f\n\r\t\v&quot;<!-- /@w --> (space, form-feed, newline, carriage return, horizontal tab and vertical tab).
</p></dd>
<dt><code>output-file <var>file</var></code></dt>
<dd><p>Output is written to <var>file</var> instead of the default output (standard output or given by <samp>-o, --output</samp>). 
If - is given the output is written to standard output.
</p></dd>
<dt><code>group_header <var>picture</var></code></dt>
<dd><p>If a record has a level and a group name defined, 
<var>picture</var> is printed before the first record in a group or if the group name has changed in the same level.
<strong>Note</strong>: Level related pictures can contain printing directives <code>%g</code> and <code>%n</code> only.
</p></dd>
<dt><code>group_trailer <var>picture</var></code></dt>
<dd><p>If a record has a level and a group name defined, 
<var>picture</var> is printed after the records in lower levels are printed or if the group name has changed in the 
same level or if a higher level record is found.
</p></dd>
<dt><code>element_header <var>picture</var></code></dt>
<dd><p>If a record has a level and a element name defined, <var>picture</var> is printed before the records contents.
</p></dd>
<dt><code>element_trailer <var>picture</var></code></dt>
<dd><p>If a record has a level and a element name defined, <var>picture</var> is printed after the records contents or after 
the following lower level records.
</p></dd>
<dt><code>hex-caps yes|no</code></dt>
<dd><p>Print hexadecimal numbers in capital letters. Default is no.
</p></dd>
</dl>

<a name="Lookup"></a>
<h4 class="subheading">Lookup</h4>
<p>Keyword <code>lookup</code> specifies a lookup table which can be searched using field contents. Found values can
be printed using output directives <code>%l</code> and <code>%L</code>.
</p>
<p>The lookup table notation:
<br>
</p>
<div class="example">
<pre class="example">lookup <var>name</var> {
    <i>option value</i> &hellip;
    &hellip;
}
</pre></div>

<p>Lookup options:
</p><dl compact="compact">
<dt><code>search exact | longest</code></dt>
<dd><p>Search method for this table. Either exact or longest match is used when searching the table. Default is <code>exact</code>.
</p></dd>
<dt><code>pair <var>key</var> <var>value</var></code></dt>
<dd><p>Defines a key/value pair for the lookup table. In case of binary file <var>key</var> must have the same representation as
can be shown using the <code>%d</code> printing directive.
</p></dd>
<dt><code>file <var>name</var> [<var>separator</var>]</code></dt>
<dd><p>Data for the lookup table is read from file <var>name</var>. Each line in file <var>name</var> is considered as a key/value pair
separated by a single character <var>separator</var>. Default separator is semicolon. Lines without separator are silently omitted.
<strong>Note</strong>: The file size is limited by available memory because the file contents is loaded to memory. 
</p></dd>
<dt><code>default-value <var>value</var></code></dt>
<dd><p>If searching the lookup table is unsuccessful then <var>value</var> is used in printing. Default is empty string.
</p></dd>
</dl>

<a name="Constants"></a>
<h4 class="subheading">Constants</h4>
<p>Keyword <code>const</code> specifies one name/value pair which can be used as an additional output field.
Constants can be used only in field lists (option <samp>-f,--field-list</samp>, or output option <code>field-list</code>).
</p>
<p>Constants can be used to add fields to output which do not appear in input. E.g. new fields for 
separated output or adding spaces after a fixed length field (changing the field length).
</p>
<p>Note that <var>value</var> is printed as it is for every record. It cannot be changed record by record.
</p>
<p>If a constant has the same name as one of the input fields, the value <var>value</var> is printed instead of
the input field contents.
</p>
<p>The constant notation:
<br>
</p>
<div class="example">
<pre class="example">const <var>name</var> <var>value</var>
</pre></div>

<p>When <var>name</var> appears in field list it is treated as one of the input fields having contents <var>value</var>.
</p>
<a name="Filter"></a>
<h4 class="subheading">Filter</h4>
<p>Keyword <code>filter</code> defines a command that can be used to format field raw contents. Command must read the standard input
and write to standard output and it must not block. Field raw contents is filtered through the command and the output is printed as
field contents.
</p>
<p>The filter notation:
<br>
</p><div class="example">
<pre class="example">filter <var>name</var> <var>command</var>
</pre></div>

<p><var>name</var> is referred in field definition. <var>command</var> is the shell command to be executed.
</p>
<a name="Anonymization"></a>
<h4 class="subheading">Anonymization</h4>
<p>Keyword <code>anonymize</code> defines a set of fields which will be anonymized by using command line option <samp>-A,--anonymize</samp>
is given. Ffe uses non-reversible anonymization methods and preserves the original field length.
</p>
<p>Notation:
<br>
</p><div class="example">
<pre class="example">anonymize <var>name</var> {
    <i>method</i> &hellip;
    &hellip;
}
</pre></div>
<p>The anonymization will be done if command line option <samp>-A,--anonymize</samp> is given with <var>name</var>.
Anonymize options:
</p><dl compact="compact">
<dt><code>method <var>field</var> <var>method</var> <var>start</var> <var>length</var> <var>parameter</var></code></dt>
<dd><p>All fields named as <var>field</var> in the current structure will be anonymized using method <var>method</var>.
As default the whole field is anonymized. Some parts of the field can be left non-anonymized using
<var>start</var> and <var>length</var>. <var>start</var> is the byte position where the anonymization starts, first byte is number 1.
If <var>start</var> is negative the anonymization starts from the end of the field.
If <var>length</var> is given then <var>length</var> number of bytes is anonymized after start position, default value 0 means the rest of the field.
Only <var>field</var> and <var>method</var> are mandatory.
<br>
<br>
Values for <var>method</var>:
</p><dl compact="compact">
<dt><code>MASK</code></dt>
<dd><p>Field will be masked with character &rsquo;0&rsquo;. Different character can be given with <var>parameter</var>.
</p></dd>
<dt><code>RANDOM</code></dt>
<dt><code>NRANDOM</code></dt>
<dd><p>Field will be filled with randomly selected bytes.
</p></dd>
<dt><code>HASH</code></dt>
<dt><code>NHASH</code></dt>
<dd><p>Field will be filled with data from hash calculated from the original field. 
This method yields always the same result with same input. The hash length in bytes can be given with <var>parameter</var>.
Default hash length is 16, valid values for hash length are 16, 32 and 64.
</p></dd>
</dl>
<p>Methods RANDOM and HASH use characters <code>0-9,A-Z,a-z</code> and space for text fields. Methods NRANDOM and NHASH use only characters <code>0-9</code>. 
For binary fields all byte values are used. BCD coded fields are always filled with BCD values <code>0-9</code>. 
</p></dd>
</dl>

<a name="Command-Substitution"></a>
<h4 class="subheading">Command Substitution</h4>
<p>Command Substitution allows the output of a command to replace parts of the configuration file. Syntax for 
command substitution is:
<br>
<br>
&lsquo;<code>command</code>&lsquo;
<br>
<br>
The <code>command</code> is executed and the &lsquo;<code>command</code>&lsquo; is substituted with the standard output of
the command, with any trailing newlines deleted. Command substitutions may not be nested.
</p>
<p>Before executing the <code>command</code> <code>ffe</code> sets following environment variables:
</p><dl compact="compact">
<dt><code>FFE_STRUCTURE</code></dt>
<dd><p>The name of the structure from <samp>-s,--structure</samp>.
</p></dd>
<dt><code>FFE_OUTPUT</code></dt>
<dd><p>The name of the output file from <samp>-o,--output</samp>.
</p></dd>
<dt><code>FFE_FORMAT</code></dt>
<dd><p>The name of the output format from <samp>-p,--print</samp>.
</p></dd>
<dt><code>FFE_FIRST_FILE</code></dt>
<dd><p>The name of the first input file.
</p></dd>
<dt><code>FFE_FILES</code></dt>
<dd><p>A space-separated list of all input files.
</p></dd>
</dl>
<p>If variable is already set it will not be replaced.
</p>
<a name="Input-Preprocessor"></a>
<h4 class="subheading">Input Preprocessor</h4>
<p>It is possible to define an input preprosessor for <code>ffe</code>. An input preprocessor is simply an executable program
which writes the contents of the input file to standard output which will be read by <code>ffe</code>. If the input preprosessor
does not write any characters on its standard output, then <code>ffe</code> uses the original file.
</p>
<p>To set up an input preprocessor, set the <code>FFEOPEN</code> environment variable to a command line which will invoke your input preprocessor.
This command line should include  one  occurrence  of  the string <code>%s</code>,
which will be replaced by the input filename when the input preprocessor command is invoked.
</p>
<p>The input preprocessor is not used if <code>ffe</code> is reading standard input.
</p>
<p>Convenient way is to use <code>lesspipe</code> (or <code>lesspipe.sh</code>), which is available in many UNIX-systems, for example
<br>
</p><div class="example">
<pre class="example">export FFEOPEN=&quot;/usr/bin/lesspipe %s&quot;
</pre></div>

<p>Using the example above is it possible to give a zipped input file to <code>ffe</code>, then the input processor will unzip the
file before it is processed by <code>ffe</code>.
</p>
<hr>
<a name="Guessing"></a>
<a name="Guessing-1"></a>
<h3 class="section">3.3 Guessing</h3>
<a name="index-guess"></a>
<p>If <samp>-s</samp> is not given, <code>ffe</code> tries to guess the input structure. 
</p>
<p>When guessing binary data <code>ffe</code> reads the first block of input data and tries to match the structure definitions
from configuration file to that block. The input block size is the maximum binary block size found in configuration file.
</p>
<p>When guessing text data <code>ffe</code> reads the first 10 000 lines or 1 MB of input data and tries to match the structure definitions
from configuration file to input stream. If all lines match one and only one structure, the structure is used
for reading the input file.
</p>
<p>Guessing uses following execution cycle:
</p>
<ol>
<li> A input line or a binary block is read
</li><li> All record <code>id</code>&rsquo;s are compared to the input data, if all <code>id</code>&rsquo;s of a record match 
the input date and the
records line length matches the total length (or total count for separated structure) of the fields,
the record is considered to match the input line. If there are no <code>id</code>&rsquo;s, 
only the line length or field count is checked. In case of binary data only  <code>id</code>&rsquo;s are used in matching.
</li><li> In case of text data: If all lines match at least one of the records in a particular structure, the structure is considered as selected. 
There must be only one structure matching all lines used for guessing.

<p>In case of binary data: If the first block matches at least one record of a structure, the structure is considered as selected. Only one structure must match.
</p>
</li></ol>


<hr>
<a name="Limits"></a>
<a name="Limitations"></a>
<h3 class="section">3.4 Limitations</h3>
<a name="index-big-files"></a>
<a name="index-limits"></a>

<p>At least in GNU/Linux <code>ffe</code> should be able to handle big files (&gt; 4 GB), other
systems are not tested.
</p>
<p>Regular expression can be used in operator <strong>?</strong> in option <samp>-e</samp>, <samp>--expression</samp> and in record key word <code>rid</code> only in systems where
regular expression functions (regcomp, regexec, &hellip;) are available.
</p>
<hr>
<a name="ffe-configuration"></a>
<a name="How-ffe-works"></a>
<h2 class="chapter">4 How <code>ffe</code> works</h2>
<p>Following examples use two different input files: 
</p><a name="Fixed-length-example"></a>
<h4 class="subheading">Fixed length example</h4>
<p>Fixed length personnel file with header and trailer, line (record) is identified by the
first byte (H = Header, E = Employee, B = Boss, T = trailer).
</p><div class="example">
<pre class="example">$cat personnel.fix
H2006-02-25
EJohn     Ripper       23
BScott    Tiger        45
EMary     Moore        41
ERidge    Forrester    31
T0004
$
</pre></div>

<p>Structure for reading file above. Note that record &lsquo;<samp>boss</samp>&rsquo; reuses fields from &lsquo;<samp>employee</samp>&rsquo;.
</p>
<div class="example">
<pre class="example">structure personel_fix {
    type fixed
    record header {
        id 1 H
        field type 1
        field date 10
    }
    record employee {
        id 1 E
        field EmpType 1
        field FirstName 9
        field LastName  13
        field Age 2
    }
    record boss {
        id 1 B
        fields-from employee
    }
    record trailer {
        id 1 T
        field type 1
        field count 4
    }
}
</pre></div>

<a name="Separated-example"></a>
<h4 class="subheading">Separated example</h4>
<p>Same file as above, but now separated by comma.
</p>
<div class="example">
<pre class="example">$cat personnel.sep
H,2006-02-25
E,john,Ripper,23
B,Scott,Tiger,45
E,Mary,Moore,41
E,Ridge,Forrester,31
T,0004
$
</pre></div>

<p>Structure for reading file above. Note that the field lengths are not needed in separated format. Length
is need if the separated data is to be printed in fixed length format.
</p>
<div class="example">
<pre class="example">structure personel_sep {
    type separated ,
    record header {
        id 1 H
        field type 
        field date 
    }
    record employee {
        id 1 E
        field type 
        field FirstName 
        field LastName 
        field Age 
    }
    record boss {
        id 1 B
        fields-from employee
    }
    record trailer {
        id 1 T
        field type 
        field count
    }
}
</pre></div>

<a name="Printing-in-XML-format"></a>
<h4 class="subheading">Printing in XML format</h4>
<p>Data in examples above can be printed in XML using output definition like:
</p>
<div class="example">
<pre class="example">output xml {
    file_header &quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot;?&gt;\n&quot;
    data &quot;&lt;%n&gt;%t&lt;/%n&gt;\n&quot;
    record_header &quot;&lt;%r&gt;\n&quot;
    record_trailer &quot;&lt;/%r&gt;\n&quot;
    indent &quot; &quot;
}
</pre></div>

<p>Example output using command (assuming definitions above are saved in ~/.fferc)
</p>
<p><code>ffe -p xml personnel.sep</code>
</p>
<div class="example">
<pre class="example">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
 &lt;header&gt;
  &lt;type&gt;H&lt;/type&gt;
  &lt;date&gt;2006-02-25&lt;/date&gt;
 &lt;/header&gt;
 &lt;employee&gt;
  &lt;type&gt;E&lt;/type&gt;
  &lt;FirstName&gt;john&lt;/FirstName&gt;
  &lt;LastName&gt;Ripper&lt;/LastName&gt;
  &lt;Age&gt;23&lt;/Age&gt;
 &lt;/employee&gt;
 &lt;boss&gt;
  &lt;type&gt;B&lt;/type&gt;
  &lt;FirstName&gt;Scott&lt;/FirstName&gt;
  &lt;LastName&gt;Tiger&lt;/LastName&gt;
  &lt;Age&gt;45&lt;/Age&gt;
 &lt;/boss&gt;
 &lt;employee&gt;
  &lt;type&gt;E&lt;/type&gt;
  &lt;FirstName&gt;Mary&lt;/FirstName&gt;
  &lt;LastName&gt;Moore&lt;/LastName&gt;
  &lt;Age&gt;41&lt;/Age&gt;
 &lt;/employee&gt;
 &lt;employee&gt;
  &lt;type&gt;E&lt;/type&gt;
  &lt;FirstName&gt;Ridge&lt;/FirstName&gt;
  &lt;LastName&gt;Forrester&lt;/LastName&gt;
  &lt;Age&gt;31&lt;/Age&gt;
 &lt;/employee&gt;
 &lt;trailer&gt;
  &lt;type&gt;T&lt;/type&gt;
  &lt;count&gt;0004&lt;/count&gt;
 &lt;/trailer&gt;
</pre></div>
<a name="Printing-sql-commands"></a>
<h4 class="subheading">Printing sql commands</h4>
<p>Data in examples above can be loaded to database by generated sql commands. Note that the header and trailer
are not loaded, because only fields &lsquo;<samp>FirstName</samp>&rsquo;,&lsquo;<samp>LastName</samp>&rsquo; and &lsquo;<samp>Age</samp>&rsquo; are printed and &lsquo;<samp>no-data-print</samp>&rsquo;
is set as no. This prevents the &lsquo;<samp>record_header</samp>&rsquo; and &lsquo;<samp>record_trailer</samp>&rsquo; to be printed for file header and trailer.
</p>
<div class="example">
<pre class="example">output sql {
    file_header &quot;delete table boss;\ndelete table employee;\n&quot;
    record_header &quot;insert into %r values(&quot;
    data &quot;'%t'&quot;
    separator &quot;,&quot;
    record_trailer &quot;);\n&quot;
    file_trailer &quot;commit\nquit\n&quot;
    no-data-print no
    field-list FirstName,LastName,Age
}
</pre></div>

<p>Output from command
</p>
<p><code>ffe -p sql personnel.sep</code>
</p>
<div class="example">
<pre class="example">delete table boss;
delete table employee;
insert into employee values('john','Ripper','23');
insert into boss values('Scott','Tiger','45');
insert into employee values('Mary','Moore','41');
insert into employee values('Ridge','Forrester','31');
commit
quit
</pre></div>
<a name="Human-readable-output"></a>
<h4 class="subheading">Human readable output</h4>
<p>This output format shows the fields in format suitable for displaying in screen or printing.
</p>
<div class="example">
<pre class="example">output nice {
    record_header &quot;%s - %r - %f - %o\n&quot;
    data &quot;%n=%t\n&quot;
    justify =
    indent &quot; &quot;
}
</pre></div>

<p>Output from command
</p>
<p><code>ffe -p nice personnel.fix</code>
</p><div class="example">
<pre class="example"> personel - header - personnel.fix - 1
  type=H
  date=2006-02-25
 
 personel - employee - personnel.fix - 2
    EmpType=E
  FirstName=John
   LastName=Ripper
        Age=23
 
 personel - boss - personnel.fix - 3
    EmpType=B
  FirstName=Scott
   LastName=Tiger
        Age=45
 
 personel - employee - personnel.fix - 4
    EmpType=E
  FirstName=Mary
   LastName=Moore
        Age=41
 
 personel - employee - personnel.fix - 5
    EmpType=E
  FirstName=Ridge
   LastName=Forrester
        Age=31
 
 personel - trailer - personnel.fix - 6
   type=T
  count=0004
</pre></div>

<a name="HTML-table"></a>
<h4 class="subheading">HTML table</h4>
<p>Personnel data can be displayed as HTML table using output like:
</p>
<div class="example">
<pre class="example">output html {
    file_header &quot;&lt;html&gt;\n&lt;head&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;table border=\&quot;1\&quot;&gt;\n&lt;tr&gt;\n&quot;
    header &quot;&lt;th&gt;%n&lt;/th&gt;\n&quot;
    record_header &quot;&lt;tr&gt;\n&quot;
    data &quot;&lt;td&gt;%t&lt;/td&gt;\n&quot;
    file_trailer &quot;&lt;/table&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n&quot;
    no-data-print no
}
</pre></div>

<p>Output from command
</p>
<p><code>ffe -p html -f FirstName,LastName,Age personnel.fix</code>
</p><div class="example">
<pre class="example">&lt;html&gt;
&lt;head&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;table border=&quot;1&quot;&gt;
&lt;tr&gt;
&lt;th&gt;FirstName&lt;/th&gt;
&lt;th&gt;LastName&lt;/th&gt;
&lt;th&gt;Age&lt;/th&gt;

&lt;tr&gt;
&lt;td&gt;John&lt;/td&gt;
&lt;td&gt;Ripper&lt;/td&gt;
&lt;td&gt;23&lt;/td&gt;

&lt;tr&gt;
&lt;td&gt;Scott&lt;/td&gt;
&lt;td&gt;Tiger&lt;/td&gt;
&lt;td&gt;45&lt;/td&gt;

&lt;tr&gt;
&lt;td&gt;Mary&lt;/td&gt;
&lt;td&gt;Moore&lt;/td&gt;
&lt;td&gt;41&lt;/td&gt;

&lt;tr&gt;
&lt;td&gt;Ridge&lt;/td&gt;
&lt;td&gt;Forrester&lt;/td&gt;
&lt;td&gt;31&lt;/td&gt;

&lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre></div>

<a name="Using-expression"></a>
<h4 class="subheading">Using expression</h4>
<p>Printing only Scott&rsquo;s record using expression with previous example:
</p>
<p><code>ffe -p html -f FirstName,LastName,Age -e FirstName^Scott personnel.fix</code>
</p><div class="example">
<pre class="example">&lt;html&gt;
&lt;head&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;table border=&quot;1&quot;&gt;
&lt;tr&gt;
&lt;th&gt;FirstName&lt;/th&gt;
&lt;th&gt;LastName&lt;/th&gt;
&lt;th&gt;Age&lt;/th&gt;

&lt;tr&gt;
&lt;td&gt;Scott&lt;/td&gt;
&lt;td&gt;Tiger&lt;/td&gt;
&lt;td&gt;45&lt;/td&gt;

&lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre></div>

<a name="Using-replace"></a>
<h4 class="subheading">Using replace</h4>
<p>Make all bosses and write a new personnel file printing the fields in fixed length format
using directive <code>%D</code>:
</p>
<p>Output definition:
</p><div class="example">
<pre class="example">output fixed 
{
    data &quot;%D&quot;
}
</pre></div>

<p>Write a new file:
</p><div class="example">
<pre class="example">$ffe -p fixed -r EmpType=B -o personnel.fix.new personnel.fix
$cat personnel.fix.new
H2006-02-25
BJohn     Ripper       23
BScott    Tiger        45
BMary     Moore        41
BRidge    Forrester    31
T0004
$
</pre></div>

<a name="Using-constant"></a>
<h4 class="subheading">Using constant</h4>
<p>The length of the fields FirstName and LastName in fixed length format will be made two bytes longer.
This will be done by printing a constant after those two fields.
We use dots instead of spaces in order to make change more visible.
</p>
<p>Because we do not want to change header and trailer we need specially crafted configuration file. 
Employee and boss records will be printed using new output <var>fixed2</var> and other records will be printed using 
output <var>default</var>.
</p>
<p>New definition file <samp>new_fixed.rc</samp>:
</p><div class="example">
<pre class="example">const 2dots &quot;..&quot;

structure personel_fix {
    type fixed
    record header {
        id 1 H 
        field type 1 
        field date 10
    }
    record employee {
        id 1 E
        field EmpType 1 
        field FirstName 9
        field LastName  13
        field Age 2
        output fixed2
    }
    record boss {
        id 1 B
        fields-from employee
        output fixed2
    }
    record trailer {
        id 1 T
        field type 1 
        field count 4
    }
}

output default
{
    data &quot;%D&quot;
}

output fixed2
{
    data &quot;%D&quot;
    field-list Emptype,FirstName,2dots,LastName,2dots,Age
}
</pre></div>
<p>Print new flat file:
</p><div class="example">
<pre class="example">$ ffe -c new_fixed.rc personel_fix
H2006-02-25
EJohn     ..Ripper       ..23
BScott    ..Tiger        ..45
EMary     ..Moore        ..41
ERidge    ..Forrester    ..31
T0004
$
</pre></div>

<a name="Using-lookup-table"></a>
<h4 class="subheading">Using lookup table</h4>
<p>Lookup table is used to explain the EmpTypes contents in output format <code>nice</code>:
</p>
<p>Lookup definition:
</p><div class="example">
<pre class="example">lookup Type
{
    search exact
    pair H Header
    pair B &quot;He is a Boss!&quot;
    pair E &quot;Not a Boss!&quot;
    pair T Trailer
    default-value &quot;Unknown record type!&quot;
}   
</pre></div>
<p>Mapping the EmpType field to lookup:
</p><div class="example">
<pre class="example">structure personel_fix {
    type fixed
    record header {
        id 1 H
        field type 1
        field date 10
    }
    record employee {
        id 1 E
        field EmpType 1 Type
        field FirstName 9
        field LastName  13
        field Age 2
    }
    record boss {
        id 1 B
        fields-from employee
    }
    record trailer {
        id 1 T
        field type 1
        field count 4
    }
}
</pre></div>
<p>Adding the lookup option to output definition <code>nice</code>.
</p><div class="example">
<pre class="example">output nice {
    record_header &quot;%s - %r - %f - %o\n&quot;
    data &quot;%n=%t\n&quot;
    lookup &quot;%n=%t (%l)\n&quot;
    justify =
    indent &quot; &quot;
}
</pre></div>
<p>Running ffe:
</p><div class="example">
<pre class="example"> $ffe -p nice personnel.fix
 personel_fix - header - personel_fix - 1
  type=H
  date=2006-02-25
 
 personel_fix - employee - personel_fix - 2
    EmpType=E (Not a Boss!)
  FirstName=John
   LastName=Ripper
        Age=23
 
 personel_fix - boss - personel_fix - 3
    EmpType=B (He is a Boss!)
  FirstName=Scott
   LastName=Tiger
        Age=45
 
 personel_fix - employee - personel_fix - 4
    EmpType=E (Not a Boss!)
  FirstName=Mary
   LastName=Moore
        Age=41
 
 personel_fix - employee - personel_fix - 5
    EmpType=E (Not a Boss!)
  FirstName=Ridge
   LastName=Forrester
        Age=31
 
 personel_fix - trailer - personel_fix - 6
   type=T
  count=0004
</pre></div>

<a name="External-lookup-file"></a>
<h4 class="subheading">External lookup file</h4>
<p>In previous example the lookup data could be read from external file like:
</p>
<div class="example">
<pre class="example">$cat lookupdata
H;Header
B;He is a Boss!
E;Not a Boss!
T;Trailer
$
</pre></div>
<p>Lookup definition using file above:
</p><div class="example">
<pre class="example">lookup Type
{
    search exact
    file lookupdata
    default-value &quot;Unknown record type!&quot;
}
</pre></div>

<a name="Making-universal-csv-reader-using-command-substitution"></a>
<h4 class="subheading">Making universal csv reader using command substitution</h4>
<p>Command substitution can be used to make a configuration for reading any csv file.
The number of fields will be read from the first file using awk. 
Input file names and date are printed in the file header:
</p>
<div class="example">
<pre class="example">structure csv {
    type separated ,
    header first
    record csv {
        field-count `awk &quot;-F,&quot; 'FNR == 1 {print NF;exit;}' $FFE_FIRST_FILE`
    }
}

output default {
    file_header &quot;Files: `echo $FFE_FILES`\n`date`\n&quot;
    data &quot;%n=%d\n&quot;
    justify =
}
</pre></div>

<a name="Reading-binary-data"></a>
<h4 class="subheading">Reading binary data</h4>
<p>A binary block having a 3 byte text (ABC) in 5 bytes long space, one byte integer (35), a 32 bit integer (12345678), a double (345.385), a 3 byte bcd number (45112) and a 4 byte hexadecimal data (f15a9188) can be read using following configuration:
</p>
<div class="example">
<pre class="example">structure bin_data
{
    type binary
    record b
    {
        field text 5
        field byte_int int8
        field integer int
        field number double
        field bcd_number bcd_be_3
        field hex hex_be_4
    }
}

output default
{
    data &quot;%n = %d (%h)\n&quot;
}
</pre></div>
<p>The <code>%h</code> directive gives a hex dump of the input data.
</p>
<p>Hexadecimal dump of the data:
</p><div class="example">
<pre class="example">$ od -t x1 example_bin
0000000 41 42 43 00 08 23 4e 61 bc 00 5c 8f c2 f5 28 96
0000020 75 40 45 11 2f f1 5a 91 88
0000031
</pre></div>

<p>Using ffe:
</p><div class="example">
<pre class="example">$ffe -c example_bin.fferc -s bin_data example_bin
text = ABC (x41x42x43x00x08)
byte_int = 35 (x23)
integer = 12345678 (x4ex61xbcx00)
number = 345.385000 (x5cx8fxc2xf5x28x96x75x40)
bcd_number = 45112 (x45x11x2f)
hex = f15a9188 (xf1x5ax91x88)
</pre></div>

<p>Note that the text has only 3 characters before NULL byte. Because this example was made in little endian
machine, same result can be achieved with different configuration:
</p><div class="example">
<pre class="example">structure bin_data
{
    type binary
    record b
    {
        field text 5
        field byte_int int8
        field integer int32_le
        field number double_le
        field bcd_number bcd_be_3
        field hex hex_be_4
    }
}
</pre></div>
<p>This configuration is more portable in case the same data is to be read in a different architecture because endianess of integer and double are explicit given.
</p>
<p>If the bcd number is read with <code>bcd_le_3</code> it would look as 
</p><div class="example">
<pre class="example">bcd_number = 5411 (x45x11x2f)
</pre></div>
<p>Note that nybbles are swapped and last byte is handled as <code>f2</code> (<code>f</code> stops the printing) causing only first two bytes to be printed. 
</p>
<p>and if hexadecimal data is read with <code>hex_le_4</code> it would look as
</p><div class="example">
<pre class="example">hex = 88915af1 (xf1x5ax91x88)
</pre></div>
<p>Bytes are printed starting from the end of the data.
</p>
<a name="Printing-nested-XML"></a>
<h4 class="subheading">Printing nested XML</h4>
<p>The keyword <code>level</code> in record definition can be used to print data in multi-level nested form. In this
example a parent row is in level one and a child row is in level two. Children after a parent row belongs
to the parent before child rows, so they are enclosed in a parent element.
</p>
<p>Example data:
</p><div class="example">
<pre class="example">P,John Smith,3 
C,Kathren,6,Blue 
C,Jimmy,4,Red
C,Peter,2,Green
P,Margaret Eelers,2
C,Aden,16,White
C,Amanda,20,Black
</pre></div>

<p>A parent row consists of ID (P), parent name, and the count of the children. A child row consists of id (C), child name, age and favorite color.
</p>
<p>This can be printed in nested XML using rc file:
</p><div class="example">
<pre class="example">structure family
{
    type separated ,
    record parent
    {
        id 1 P
        field FILLER
        field Name
        field Child_count
        level 1 parent
    }

    record child
    {
        id 1 C
        field FILLER
        field Name
        field Age
        field FavoriteColor
        level 2 child children
    }
}

output nested_xml
{
    file_header &quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot;?&gt;\n&quot;
    data &quot;&lt;%n&gt;%t&lt;/%n&gt;\n&quot;
    indent &quot; &quot;
    record_trailer &quot;&quot;
    group_header &quot;&lt;%g&gt;\n&quot;
    group_trailer &quot;&lt;/%g&gt;\n&quot;
    element_header &quot;&lt;%m&gt;\n&quot;
    element_trailer &quot;&lt;/%m&gt;\n&quot;
}
</pre></div>

<p>Output:
</p>
<div class="example">
<pre class="example">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
 &lt;parent&gt;
  &lt;Name&gt;John Smith&lt;/Name&gt;
  &lt;Child_count&gt;3&lt;/Child_count&gt;
  &lt;children&gt;
   &lt;child&gt;
    &lt;Name&gt;Kathren&lt;/Name&gt;
    &lt;Age&gt;6&lt;/Age&gt;
    &lt;FavoriteColor&gt;Blue&lt;/FavoriteColor&gt;
   &lt;/child&gt;
   &lt;child&gt;
    &lt;Name&gt;Jimmy&lt;/Name&gt;
    &lt;Age&gt;4&lt;/Age&gt;
    &lt;FavoriteColor&gt;Red&lt;/FavoriteColor&gt;
   &lt;/child&gt;
   &lt;child&gt;
    &lt;Name&gt;Peter&lt;/Name&gt;
    &lt;Age&gt;2&lt;/Age&gt;
    &lt;FavoriteColor&gt;Green&lt;/FavoriteColor&gt;
   &lt;/child&gt;
  &lt;/children&gt;
 &lt;/parent&gt;
 &lt;parent&gt;
  &lt;Name&gt;Margaret Eelers&lt;/Name&gt;
  &lt;Child_count&gt;2&lt;/Child_count&gt;
  &lt;children&gt;
   &lt;child&gt;
    &lt;Name&gt;Aden&lt;/Name&gt;
    &lt;Age&gt;16&lt;/Age&gt;
    &lt;FavoriteColor&gt;White&lt;/FavoriteColor&gt;
   &lt;/child&gt;
   &lt;child&gt;
    &lt;Name&gt;Amanda&lt;/Name&gt;
    &lt;Age&gt;20&lt;/Age&gt;
    &lt;FavoriteColor&gt;Black&lt;/FavoriteColor&gt;
   &lt;/child&gt;
  &lt;/children&gt;
 &lt;/parent&gt;
</pre></div>

<a name="Some-examples-put-in-a-single-file"></a>
<h4 class="subheading">Some examples put in a single file</h4>
<div class="example">
<pre class="example">structure personel_fix {
    type fixed
    record header {
        id 1 H
        field type 1
        field date 10
    }
    record employee {
        id 1 E
        field EmpType 1 Type
        field FirstName 9
        field LastName  13
        field Age 2
    }
    record boss {
        id 1 B
        fields-from employee
    }
    record trailer {
        id 1 T
        field type 1
        field count 4
    }
}

structure personel_sep {
    type separated ,
    record header {
        id 1 H
        field type 
        field date 
    }
    record employee {
        id 1 E
        field type 
        field FirstName 
        field LastName  
        field Age 
    }
    record boss {
        id 1 B
        fields-from employee
    }
        record trailer {
        id 1 T
        field type 
        field count
    }
}

structure bin_data
{
    type binary
    record b
    {
        field text 5
        field byte_int int8
        field integer int32_le
        field number double_le
        field bcd_number bcd_be_3
        field hex hex_be_4
    }
}

output xml {
    file_header &quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot;?&gt;\n&quot;
    data &quot;&lt;%n&gt;%t&lt;/%n&gt;\n&quot;
    record_header &quot;&lt;%r&gt;\n&quot;
    record_trailer &quot;&lt;/%r&gt;\n&quot;
    indent &quot; &quot;
}

output sql {
    file_header &quot;delete table boss;\ndelete table employee;\n&quot;
    record_header &quot;insert into %r values(&quot;
    data &quot;'%t'&quot;
    separator &quot;,&quot;
    record_trailer &quot;);\n&quot;
    file_trailer &quot;commit\nquit\n&quot;
    no-data-print no
    field-list FirstName,LastName,Age
}

output nice {
    record_header &quot;%s - %r - %f - %o\n&quot;
    data &quot;%n=%t\n&quot;
    lookup &quot;%n=%t (%l)\n&quot;
    justify =
    indent &quot; &quot;
}

output html {
    file_header &quot;&lt;html&gt;\n&lt;head&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;table border=\&quot;1\&quot;&gt;\n&lt;tr&gt;\n&quot;
    header &quot;&lt;th&gt;%n&lt;/th&gt;\n&quot;
    record_header &quot;&lt;tr&gt;\n&quot;
    data &quot;&lt;td&gt;%t&lt;/td&gt;\n&quot;
    file_trailer &quot;&lt;/table&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n&quot;
    no-data-print no
}

output fixed 
{
    data &quot;%D&quot;
}

lookup Type
{
    search exact
    pair H Header
    pair B &quot;He is a Boss!&quot;
    pair E &quot;Not a Boss!&quot;
    pair T Trailer
    default-value &quot;Unknown record type!&quot;
}   
</pre></div>

<a name="Anonymization-1"></a>
<h4 class="subheading">Anonymization</h4>
<p>Anonymize fields FirstName, LastName and Age for personnel data:
</p><div class="example">
<pre class="example">anonymize personnel
{
    method FirstName HASH 2
    method LastName HASH 2
    method Age NRANDOM
}
</pre></div>

<p>Data before anonymization:
</p><div class="example">
<pre class="example">$cat personnel.fix
H2006-02-25
EJohn     Ripper       23
BScott    Tiger        45
EMary     Moore        41
ERidge    Forrester    31
T0004
</pre></div>

<p>Anonymize the data to new file <samp>personnel_anon.fix</samp> (using the default configuration file <samp>~/.fferc</samp> and raw output):
</p>
<div class="example">
<pre class="example">ffe -A personnel -praw -o personnel_anon.fix personnel.fix
</pre></div>

<p>Anonymized data:
</p><div class="example">
<pre class="example">$cat personnel_anon.fix
H2006-02-25
EJQIQ9C5oBR2rDU0qiSTv7E62
BSqUcsYzSTTNTuTraspsG4154
EMTsXkHltVMsV8qmK1tkgq 00
ER1e90zv1dFjP4 xgflVGQF87
T0004

$ffe -pnice personnel_anon.fix
 personel - header - personnel_anon.fix - 1
   type=H
   date=2006-02-25
      
 personel - employee - personnel_anon.fix - 2
     EmpType=E
   FirstName=JQIQ9C5oB
    LastName=R2rDU0qiSTv7E
         Age=62
                        
 personel - boss - personnel_anon.fix - 3
    EmpType=B
  FirstName=SqUcsYzST
   LastName=TNTuTraspsG41
        Age=54
                                          
 personel - employee - personnel_anon.fix - 4
    EmpType=E
  FirstName=MTsXkHltV
   LastName=MsV8qmK1tkgq 
        Age=00
                                                     
 personel - employee - personnel_anon.fix - 5
    EmpType=E
  FirstName=R1e90zv1d
   LastName=FjP4 xgflVGQF
        Age=87
                                                                             
 personel - trailer - personnel_anon.fix - 6
   type=T
  count=0004
</pre></div>
<p>FirstName and LastName have preserved the first letter because anonymization started from the second byte. Age is a two digit random number.
Name fields will get the same anonymized value for each run, but Age will have a random value for each run.
</p>
<a name="Using-ffe-to-test-file-integrity"></a>
<h4 class="subheading">Using <code>ffe</code> to test file integrity</h4>
<p><code>ffe</code> can be used to check flat file integrity, because <code>ffe</code> 
checks for all lines the line length and id&rsquo;s for fixed length structure 
and field count and id&rsquo;s for separated structure.
</p>
<p>Integrity can be checked using command 
</p>
<p><code>ffe -p no -l inputfiles&hellip;</code>
</p>
<p>Because option <samp>-p</samp> has value <code>no</code> nothing is printed to output except the error messages.
Option <samp>-l</samp> causes all erroneous lines to be reported, not just the first one.
</p>
<p>Example output:
</p>
<div class="example">
<pre class="example">ffe: Invalid input line in file 'inputfileB', line 14550
ffe: Invalid input line in file 'inputfileD', line 12
</pre></div>

<hr>
<a name="Problems"></a>
<a name="Reporting-Bugs"></a>
<h2 class="chapter">5 Reporting Bugs</h2>
<a name="index-bugs"></a>
<a name="index-problems"></a>

<p>If you find a bug in <code>ffe</code>, please send electronic mail to
<a href="mailto:tjsa@iki.fi">tjsa@iki.fi</a>.  Include the version number, which you can find by
running &lsquo;<samp>ffe&nbsp;<span class="nolinebreak">--version</span></samp>&rsquo;<!-- /@w -->.  Also include in your message the
output that the program produced and the output you expected.
</p>
<p>If you have other questions, comments or suggestions about
<code>ffe</code>, contact the author via electronic mail to
<a href="mailto:tjsa@iki.fi">tjsa@iki.fi</a>.  The author will try to help you out, although he
may not have time to fix your problems.
</p>
<a name="SEC_Contents"></a>
<h2 class="contents-heading">Table of Contents</h2>

<div class="contents">

<ul class="no-bullet">
  <li><a name="toc-Preliminary-information" href="#Overview">1 Preliminary information</a></li>
  <li><a name="toc-Samples-using-ffe" href="#Samples">2 Samples using <code>ffe</code></a></li>
  <li><a name="toc-How-to-run-ffe" href="#Invoking-ffe">3 How to run <code>ffe</code></a>
  <ul class="no-bullet">
    <li><a name="toc-Program-invocation" href="#Invocation">3.1 Program invocation</a></li>
    <li><a name="toc-Configuration-1" href="#Configuration">3.2 Configuration</a></li>
    <li><a name="toc-Guessing-1" href="#Guessing">3.3 Guessing</a></li>
    <li><a name="toc-Limitations" href="#Limits">3.4 Limitations</a></li>
  </ul></li>
  <li><a name="toc-How-ffe-works" href="#ffe-configuration">4 How <code>ffe</code> works</a></li>
  <li><a name="toc-Reporting-Bugs" href="#Problems">5 Reporting Bugs</a></li>
</ul>
</div>

<hr>



</body>
</html>
